<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BombStar: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BombStar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">

</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
    
        <li><a href="__Readme.html"><span>Readme</span></a></li> <!- SH Added -->
      	<li><a href="__Instructions.html"><span>Instructions</span></a></li> <!- SH Added -->
      	<li><a href="__Design.html"><span>Design</span></a></li> <!- SH Added -->
		<li><a href="index.html"><span>Doxygen Output</span></a></li> <!- SH Added -->
   
    </ul>
  </div>
</div><!-- top -->



<div class="header">
  <div class="headertitle">
<div class="title">BombStar Documentation</div>  </div>
</div><!--header-->
<div class="contents">
</div><!-- contents -->

<h3>Block Class</h3>

<p>The block class was intended to be the underlying data structure of our BombStar game. 
Our application's MainWindow would have a two dimensional array of Block objects, corresponding 
to the game board with the same number of elements in each. Each individual Block object would
contain pointer references to four adjacent Blocks. For example, if a Block could be accessed in
the main window with indexes x and y, the Block would contain the pointer references of the Blocks 
at indexes (x+1,y) (x-1,y) (x, y+1) (x, y-1). This allows some of our functions to be recursive 
functions at the Block level instead of adding more to our main window through accessing arrays. 
The Block also contained a CoordX and CoordY value. These were the same accessing indexes at the
Block level. In many cases, many Blocks will be contained in a vector<Block*>, and to have constant
time access to that Block's neighbors in MainWindow, the coordinates of the Block needed to be 
easily obtained. </p>

<p>The block class itself was not implemented with a graphical representation. Because we were 
using two dimensional arrays as well as a multi-directional list at the Block level, we wanted 
to establish the Block objects and swap values for bookkeeping instead of removing and creating
new Blocks every single time a collection of Blocks was graphically removed and needing to re-establish the Block data structures. After we switched 
to the 8x9 game board, the block class was changed to only include numerical values instead of 
graphical representations and the myRectItem class would contain all of the graphical implementations. </p>

<p>Along with separating the data structures and the graphical representation, we devised a system
that mapped an integer value to a QColor. More on this is written in the Colors Class, but the 
Block Class only contains an integer value for easy color comparisons. The same integer value between
Blocks means those Blocks have the same color. This was also applied to representing stars on the 
Blocks as well. A graphImage of 0 meant that no star was being graphically represented on that particular
Block, a graphImage of 2 meant that a star was represented on that Block. The intent was to include
bombs (now stars), as well as arrows but there wasn't enough time to properly implement arrows. 
The extra arrows would have had graphImage values of 3 and 4 for vertical and horizontal, and potentially
5 for all four directions. </p>

<p>Most of the Block functions are simple accessor or mutator functions. The only functions needing 
a more detailed explanation are foundMatch and gatherBlocks, and they will be explained in Game Play.
markedBool and coloredBool are used in many of these algorithms and will be detailed there as well.
</p>

<h3>Game Play</h3>
<p>Game play is started through either selecting a game mode, restarting your current game mode in
the pause menu, or playing another game after your current game has ended. Selecting a game mode
will set one of the three game mode flags to 1. Each potential new game started calls the startGame
function, and some pieces are not started or shown depending on the game mode flags. Endless mode 
does not show the time bar nor start the time bar. Survival mode displays and starts a slightly 
modified time bar, a progress bar. More information on these is written in the Timers section. Each new game deletes and nulls the previous board, and then
dynamically allocates and randomly generates a new board. </p>

<p>The application now waits for a mousePressEvent. The game board itself needs 1 mouse event to
properly register graphics scene mouse events. This also officially starts the game timer and enables
interaction with the myRectItems. </p>

<p>Every mouse event after the first has the same process. The game 
board mouse events are temporarily frozen to process 1 match at a time. The x and y of the event 
are obtained, which is then used to obtain a Block in the two dimensional array of objects. The code to then check for an initial match was placed in the Block class because the 
Block Class contained the appropriate references and it was another process we could move out of our
long MainWindow class. FoundMatch checks that Block objects neighboring Blocks for an equal color 
value and returns true if it finds one. If it returns true, then processMatch is called and the obtained block is sent as a parameter. 
The next mouse event still cannot start until after the mouse press event function returns to its caller, so if processMatch is called, 
mouse press events in the graphics scene will be disabled while processMatch is being executed.</p>

<p>The first thing that happens in processMatch is all of the adjacent and matching blocks are gathered. 
gatherBlocks takes in a vector<Block*> and continuously expands through recursion as long as the pointer
reference exists and the color integer value matches. This is a recursive function in the Block Class because the array 
index access function would have been messier and it allows for more code to be placed outside the 
applications long main window. markedBool is necessary to avoid endless recursion amongst different directional
accesses of the same Block object. </p>

<p>Each of the current matching and adjacent blocks are now checked for a star in the checkSpecial function.
Using the gathered blocks from the previous step, if any Block objects graph image is not 0, a number of
bookkeeping statements are executed in addition to calling bombCollector to gather blocks from a bomb
explosion. Because the explosion (collection) is a 3x3 subset of the two dimensional array of blocks centered at the 
star block, array accesses were the cleanest choice. </p>

<p>Now the blocks are sorted relatively in each column. Assuming similar x values, no 
Block further down the vector will have a lower y value. Sorting was not optimal
and very likely not necessary, but the implementation of sorting worked properly with
the rest of the algorithms. With more time, a better implementation between what sorting was intended to do
(assure proper re-coloring order) and how determing new colors was implemented (assuming the blocks were sorted).</p>

<p>The conclusion of sorting leaves every single collected block (and the corresponding rectItem) as 
Black. A timer is placed here to force the game to show the blacking transition. This is discussed more
in the Timers section.</p>

<p>The score and bomb bar are updated. Scoring is described in the Score Class and the ScoreFrame Class, 
and the bomb bar (which is similar to the time bar) is described in the Timers section. The progress bar
is updated if you are playing in survival mode. </p>

<p>Finally the new colors are determined. The algorithm will search upwards in a column for 
a color that a particular Block can steal. Stars also have to properly be stolen as well. coloredBool is used to determine if a Block needs a 
color change. We could have also used the black color to check for necessary color changes, but while
we didn't know how to force transitions a more intelligent method could not be implemented. This is 
done using array accessing because the code is slightly cleaner to decrement the y index value as 
searching upwards in a column. </p>

<p>The game now waits for another mouse event. The game ends when the user exits the game or when the time runs out.</p>

<h3>User Interface</h3>
<b>Primary author: Devin Rusnak</b>


<h3>Timers</h3>
<b>Primary author: Mikael Son</b>

<h3>Shuffling</h3>
<b>Primary author: Shannon Harwick</b>

<h3>Scoring</h3>
<b>Primary author: Shannon Harwick</b>
[[TO BE COMPLETED]]

<h3>Color Schemes</h3>
<b>Primary author: Shannon Harwick</b>
[[TO BE COMPLETED]]


<h3>Game Modes</h3>
<b>Primary author: Daniel/Mike</b>
[[TO BE COMPLETED]]

<h3>User Feedback</h3>
<b>Primary author: Daniel</b>
[[TO BE COMPLETED]]

<h3>Unresolved Issues</h3>
<b>Primary author: All</b>
[[TO BE COMPLETED]]



</body>
</html>