<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BOMBSTAR: Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BOMBSTAR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">

</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
    
        <li><a href="__Readme.html"><span>Readme</span></a></li> <!- SH Added -->
      	<li><a href="__Instructions.html"><span>Instructions</span></a></li> <!- SH Added -->
      	<li><a href="__Design.html"><span>Design</span></a></li> <!- SH Added -->
		<li><a href="index.html"><span>Doxygen Output</span></a></li> <!- SH Added -->
   
    </ul>
  </div>
</div><!-- top -->



<div class="header">
  <div class="headertitle">
<div class="title">BOMBSTAR Documentation</div>  </div>
</div><!--header-->
<div class="contents">
</div><!-- contents -->

<h3>Introduction</h3>
<p>Below we have included all of the important components as listed above. Each
section has at least one author describing the relavant components. </p>





<h3>Game Play</h3>
<b>Primary Author: Daniel Keasler</b>

<p>Game play is started through either selecting a game mode, restarting your current game mode in
the pause menu, or playing another game after your current game has ended. Selecting a game mode
will set one of the three game mode flags to 1. Each potential new game started calls the startGame
function, and some pieces are not started or shown depending on the game mode flags. Endless mode 
does not show the time bar nor start the time bar. Survival mode displays and starts a slightly 
modified time bar, a progress bar. More information on these is written in the Timers section. Each new game deletes and nulls the previous board, and then
dynamically allocates and randomly generates a new board. </p>

<p>The application now waits for a mousePressEvent. The game board itself needs 1 mouse event to
properly register graphics scene mouse events. This also officially starts the game timer and enables
interaction with Blocks. All game play events are executed from MainWindow_UI.cpp unless stated otherwise. </p>

<p>Every mouse event after the first has the same process. The game 
board mouse events are temporarily frozen to process 1 match at a time. The x and y of the event 
are obtained, which is then used to obtain a Block in the two dimensional array of objects. The code to then check for an initial match was placed in the Block class because the 
Block Class contained the appropriate references and it was another process we could move out of our
long MainWindow class. FoundMatch checks that Block objects neighboring Blocks for an equal color 
value and returns true if it finds one. If it returns true, then processMatch is called and the obtained block is sent as a parameter. 
The next mouse event still cannot start until after the mouse press event function returns to its caller, so if processMatch is called, 
mouse press events in the graphics scene will be disabled while processMatch is being executed.</p>

<p>The first thing that happens in processMatch is all of the adjacent and matching blocks are gathered. 
gatherBlocks takes in a vector<Block*> and continuously expands through recursion as long as the pointer
reference exists and the color integer value matches. This is a recursive function in the Block Class because the array 
index access function would have been messier and it allows for more code to be placed outside the 
applications long main window. markedBool is necessary to avoid endless recursion amongst different directional
accesses of the same Block object. </p>

<p>Each of the current matching and adjacent blocks are now checked for a star in the checkSpecial function.
Using the gathered blocks from the previous step, if any Block objects graph image is not 0, a number of
bookkeeping statements are executed in addition to calling bombCollector to gather blocks from a bomb
explosion. Because the explosion (collection) is a 3x3 subset of the two dimensional array of blocks centered at the 
star block, array accesses were the cleanest choice. </p>

<p>Now the blocks are sorted relatively in each column. Assuming similar x values, no 
Block further down the vector will have a lower y value. Sorting was not optimal
and very likely not necessary, but the implementation of sorting worked properly with
the rest of the algorithms. With more time, a better implementation between what sorting was intended to do
(assure proper re-coloring order) and how determing new colors was implemented (assuming the blocks were sorted).</p>

<p>The conclusion of sorting leaves every single collected block as 
Black. A timer is placed here to force the game to show the blacking transition. This is discussed more
in the Timers section.</p>

<p>The score and bomb bar are updated. Scoring is described in the Score Class and the ScoreFrame Class, 
and the bomb bar (which is similar to the time bar) is described in the Timers section. The progress bar
is updated if you are playing in survival mode. </p>

<p>Finally the new colors are determined. The algorithm will search upwards in a column for 
a color that a particular Block can steal. Stars also have to properly be stolen as well. coloredBool is used to determine if a Block needs a 
color change. We could have also used the black color to check for necessary color changes, but while
we didn't know how to force transitions a more intelligent method could not be implemented. This is 
done using array accessing because the code is slightly cleaner to decrement the y index value as 
searching upwards in a column. </p>

<p>The game now waits for another mouse event. The game ends when the user exits the game or when the time runs out.</p>

<h3>Block Class</h3>
<b>Primary Author: Daniel Keasler</b>

<br><br>
<img src="./UML Diagrams/Block.jpg" alt="Block Object">
<br>

<p>The block class was intended to be the data structure of our BOMBSTAR game. 
Our application's MainWindow would have a two dimensional array of Block objects, corresponding 
to the game board with the same number of elements in each. Each individual Block object would
contain pointer references to four adjacent Blocks. For example, if a Block could be accessed in
the main window with indexes x and y, the Block would contain the pointer references of the Blocks 
at indexes (x+1,y) (x-1,y) (x, y+1) (x, y-1). This allows some of our functions to be recursive 
functions at the Block level instead of adding more to our main window through accessing arrays. 
The Block also contained a CoordX and CoordY value. These were the same accessing indexes at the
Block level. In many cases, many Blocks will be contained in a vector<Block*>, and to have constant
time access to that Block's neighbors in MainWindow, the coordinates of the Block needed to be 
easily obtained. </p>

<p>The block class later was changed to inherit from QGraphicsRectItem. By doing this, we could reimplement
the mouse press event for game play interaction and the blocks could be displayed on a QGraphicsScene. </p>

<p>Along with inheriting from QGraphicsRectItem, we devised a system 
that mapped an integer value to a QColor. More on this is written in the Colors Schemes, but the 
Block Class only contains an integer value for easy color comparisons. The same integer value between
Blocks means those Blocks have the same color. This was also applied to representing stars on the 
Blocks as well. A graphImage of 0 meant that no star was being graphically represented on that particular
Block, a graphImage of 2 meant that a star was represented on that Block. This numbering was originally intended for 
bombs (now stars) as well as arrows but there wasn't enough time to properly implement arrows. 
The extra arrows would have had graphImage values of 3 and 4 for vertical and horizontal, and potentially
5 for all four directions. </p>

<p>The stars are made from QGraphicsSimpleTextItems with unicode character 0x2605 and are members of the Block class. 
Each star is created when the Block is created, and then a pointer is assigned to that Block's star pointer (textPtr) when a star is generated.
The function that generates coordinates for the new star can also take in known coordinates for relocation; and in any case that a star is removed
from a location, that star is nulled and removed from the scene even if it is being redrawn at another location. 
And then a new star is created and assigned to the proper location. A smarter and faster system could
have been implemented had there been more time. </p>

<p>Most of the Block functions are simple accessor or mutator functions. The only functions needing 
a more detailed explanation are foundMatch and gatherBlocks, and they will be explained in Game Play.
markedBool and coloredBool are used in many of these algorithms and will be detailed there as well.
</p>

<h3>User Interface</h3>
<b>Primary author: Devin Rusnak</b>


<h3>Timers</h3>
<b>Primary author: Mikael Son</b>


<div>
<h3>Shuffling</h3>
<b>Primary author: Shannon Harwick</b><br>

<br>
<i>Shuffle Design</i>

<p>
A key fault with the original Plock game is that its only shuffling mechanism (Random Shuffle)
did not provide much reward for those players who attempted to eliminate blockS strategically
rather than by spam-clicking.

The penalty to shuffling is the time it requires to analyze a new board.  This penalty is not 
felt by spam clickers but can be a major obstacle for strategists.  

The rewards are also unbalanced. 
The Random Shuffle rewards the spam-clicker by easily opening up new clickable paths.
The strategists's board, on the other hand, may be destroyed because a major block group
could be split into smaller pieces that cannot be easily connected.  Again, the spammer 
does not suffer this consequence.  

We incorporated this feature in our own game because it makes the game more exciting by 
allowing the user to recover from a board with few options.  However, we added two more
shuffling mechanism that offer better rewards to players who think.
</p>

<p>
The first new shuffle method we implement is the Flip.  This simply flips the board
along the central horizontal axis.  The top row and the bottom row swap places, 
as do the 2nd and the 2nd-to-last rows, etc.  Note that this method is reversible
by simply calling it twice.

This method won't give any benefit to the
spammer, but it allows the strategist to maintain a large group of blocks but change
the side on which new blocks will fall.  The cost is minimal since the structure of the
board is simply a reflection of the board the user was just looking at.  At one point,
we implemented a similar flip around the vertical axis.  However, this opens up no new options
to the player, so we removed it.
</p>
<p>
The second new shuffle method is the Rotate, which rotates the board 180 degrees around 
the board's center.  Thus the top left corner of the board rotates to become the bottom 
right corner.  This method, like Flip, is easily reversible and provides benefits only
to a strategist.
</p>


<br>
<i>Shuffle Implementation</i>
<p>
Each shuffling strategy is performed via its own method: shufflePressed(), rotate(), and horizontalFlip().
In each case, the colors and bombs are traded pairwise for a number of pairs of blocks.
After swapping, the blocks are repainted.  
The swaps are as follows:
<ul>
<li>For Random Shuffle, 5,184 (= the square of the area of the game board) random trades occur.</li>
<li>For Rotate, all the blocks on the left side of the board are traded with their appropriate 
match on the right side of the board (e.g., top left corner and bottom right corner).</li>
<li>For Flip, all the blocks on the top half of the board are traded with their appropriate 
match on the bottom half of the board (e.g., top left corner and bottom left corner).</li>
</ul>
</p>


<ul> 
<i><a href="../code/mainwindow_ui.cpp">Click here for code.</a></i>
<br>Search for the following terms to find relevant section of code.
<li>void MainWindow::horizontalFlip()</li>
<li>void MainWindow::rotate()</li>
<li>void MainWindow::shufflePressed()</li>
</ul>


</div>



<h3>Scoring</h3>
<b>Primary author: Shannon Harwick</b>

<br><i>Score Design</i>
<p>
The score is designed to reward a player for thinking rather than random clicking.  A
thoughtful player must manipulate the board to create opportunities to eliminate 
very large groups of blocks.  In Plock, scoring is quadratic based on the number of
blocks eliminated in one click.  This does make larger groups worth more points per
block than smaller groups, but our user testing revealed that
the gain does not compensate for the loss in quantity due to spam-clicking.  

We considered various mechanisms to push the player away from spam-clicking:
<ul>
<li>Subtract points for clicking single blocks</li>
<li>Decrease the bomb bar for clicking single blocks</li>
<li>Decrease the time bar for clicking single blocks</li>
<li>Increase the degree of the polynomial in the scoring equation</li>
</ul>

We ultimately chose the last because it offers the player a reward for good behavior 
rather than punishment for bad.  The final score equation is: 
<br><br>
<ul>Score = Multiplier * (n-1)^4
<br>where n = # of eliminated blocks
</ul><br>
</p>

<p>
We have implemented an endless mode, but sadly, we can't give an infinite number of points.
In order to handle very large scores and multipliers, we implemented a score cap of 
100,000,000 and a multiplier cap of 50.  Once a player reaches these scores, he or she 
may continue to play, but no further points or multiplier levels may be attained.  We
considered changing the score variable to a long long type in order to allow even 
higher scores, but we decided this would require changes to the user interface that would
not be visually appealing.  
</p>

<i>Score Implementation</i>


<br><br>
<img src="./UML Diagrams/Score.jpg" alt="Score Object">
<br>


<br><br>
<img src="./UML Diagrams/ScoreFrame.jpg" alt="Score Frame Object">
<br>

<br><i><a href="../code/Score.cpp">Click here for Score code.</a></i><br>
<br><i><a href="../code/ScoreFrame.cpp">Click here for ScoreFrame code.</a></i><br>

<p>
The score is stored in a Score object as an integer.  Every time blocks are eliminated, 
updateScore() is called to increment the current score value with the value of the 
new blocks eliminated.  Originally the plan was to incorporate a speed bonus (i.e., 
the player would get extra points for multiple successful moves in a short time period).  
We ultimately chose not to implement this, as it offers a benefit to spam-clickers.  
Thus, in our current implementation, the speedBonus input is always set to false.  
</p>

<p>
The Score object also contains the current multiplier.  The multiplier reflects the 
number of bombs that have been eliminated.  Eliminate more bombs to get a higher multiplier.
Once a certain multiplier has been reached, all subsequent points earned are multiplied
by that value before adding to the score.  The multiplier begins the game at 1 and is 
incremented every time a bomb is eliminated.  
</p>

<p>
When a new game is started, resetScore() is called to reset the multiplier to 1 and 
the current score to 0.  
</p>

<p>
A separate item, ScoreFrame, is created for the score board.  After the score has been
updated, this change must be reflected on the score board viewed by the player.  The 
update() method makes this update.  When the game is reset, resetScoreBoard() sets the 
score board back to 0.  
</p>


<h3>Color Schemes</h3>
<b>Primary author: Shannon Harwick</b>

<br><br><i>Color Scheme Design</i>
<p>
In response to feedback from our presentations and from our test users, we 
decided to implement multiple color schemes and to include a Setting menu where a user
can choose the color scheme that most appeals to him or her.  Of the 5 color schemes,
four are colorblindness-safe.  We included one scheme that is not color-blind safe because 
some of the users who do <i>not</i> suffer from colorblindness found some of the colors 
too similar in the safe schemes.  The source for the color schemes is: 
<a href="http://colorbrewer2.org">Colorbrewer</a>.  Note that the background for all 
color schemes was chosen to be the most extreme shade of black.  
This is necessary since our game is quite color-intensive and thus requires a strong 
contrast.  
</p>



<i>Color Scheme Implementation</i>

<br><br>
<img src="./UML Diagrams/Colors.jpg" alt="Color Object">
<br>

<br><i><a href="../code/Colors.cpp">Click here for Color code.</a></i><br>

<p>
All 5 color schemes were placed into a single Color object.  Each color scheme is 
represented by an integer value from 0 to 4 (int colorScheme).  The active color scheme 
is contained in an array (QColor colorArray[7]) and is used to create 
a QPalette that is used to paint all objects.  
</p>
<p>
When the user changes the Color Scheme 
setting, this is implemented by changing the integer in the Color object, updating the colorArray, updating the 
QPalette, and repainting all existing objects.  This is completed by attaching a slot 
(changeColorScheme) to the QSlider used by the player to adjust the setting.  
The QPalette is updated in MainWindow::changeColorScheme().  After the palette is created,
the gameboard, all QPushButtons, and all QLabels are repainted.  The QPushButtons and 
QLabels are stored in their own vectors (labelVector and buttonVector) to facilitate this
process.  
</p>


<i>Bug</i><br><br>
One bug remains outstanding here.  QPushButtons do not respond to color changes 
on all machines/AVDs (Only 1 of our 4 computers shows the changes in the QPushButtons).  
This is true regardless of whether color changes are implemented 
using style sheets or QPalette (both techniques work correctly on the 1 computer).  
The other objects change color as expected.  

<h3>Game Modes</h3>
<b>Primary author: Daniel/Mike/Devin</b>
[[TO BE COMPLETED]]

<h3>User Feedback</h3>
<b>Primary author: Daniel Keasler</b>
<p>In the last month of the project we had a playable game that we showed to family and friends and they gave us excellent feedback.
We were first asked to show your score after the game ended, which resulted in displaying a game over menu that showed your score.
We had multiple complaints about colors. So we implemented color schemes the user could choose through the settings menu. This is
discussed more in the color schemes section. Another observation from others playing the game was that spam clicking was more 
successful. Since our application is intended for a phone and we never tested it on a phone, we can't assume anything for 
finger presses but we did incentivize scoring to make it worth more for thinking about what blocks you were clearing. This 
is discussed in the Scoring section. </p>

<h3>Unresolved Issues</h3>
<b>Primary author: All</b>



</body>
</html>