<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BombStar: Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BombStar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">

</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
    
        <li><a href="__Readme.html"><span>Readme</span></a></li> <!- SH Added -->
      	<li><a href="__Instructions.html"><span>Instructions</span></a></li> <!- SH Added -->
      	<li><a href="__Design.html"><span>Design</span></a></li> <!- SH Added -->
		<li><a href="index.html"><span>Doxygen Output</span></a></li> <!- SH Added -->
   
    </ul>
  </div>
</div><!-- top -->



<div class="header">
  <div class="headertitle">
<div class="title">BombStar Documentation</div>  </div>
</div><!--header-->
<div class="contents">
</div><!-- contents -->

<h3>Introduction</h3>






<h3>Block Class</h3>
<b>Primary Author: Daniel Keasler</b>

<p>The block class was intended to be the data structure of our BombStar game. 
Our application's MainWindow would have a two dimensional array of Block objects, corresponding 
to the game board with the same number of elements in each. Each individual Block object would
contain pointer references to four adjacent Blocks. For example, if a Block could be accessed in
the main window with indexes x and y, the Block would contain the pointer references of the Blocks 
at indexes (x+1,y) (x-1,y) (x, y+1) (x, y-1). This allows some of our functions to be recursive 
functions at the Block level instead of adding more to our main window through accessing arrays. 
The Block also contained a CoordX and CoordY value. These were the same accessing indexes at the
Block level. In many cases, many Blocks will be contained in a vector<Block*>, and to have constant
time access to that Block's neighbors in MainWindow, the coordinates of the Block needed to be 
easily obtained. </p>

<p>The block class later was changed to inherit from QGraphicsRectItem. By doing this, we could reimplement
the mouse press event for game play interaction and the blocks could be displayed on a QGraphicsScene. </p>

<p>Along with inheriting from QGraphicsRectItem, we devised a system 
that mapped an integer value to a QColor. More on this is written in the Colors Class, but the 
Block Class only contains an integer value for easy color comparisons. The same integer value between
Blocks means those Blocks have the same color. This was also applied to representing stars on the 
Blocks as well. A graphImage of 0 meant that no star was being graphically represented on that particular
Block, a graphImage of 2 meant that a star was represented on that Block. This numbering was originally intended for 
bombs (now stars) as well as arrows but there wasn't enough time to properly implement arrows. 
The extra arrows would have had graphImage values of 3 and 4 for vertical and horizontal, and potentially
5 for all four directions. </p>

<p>The stars are made from QGraphicsSimpleTextItems with unicode character 0x2605 and are members of the Block class. 
Each star is created when the Block is created, and then a pointer is assigned to that Block's star pointer (textPtr) when a star is generated.
The function that generates coordinates for the new star can also take in known coordinates for relocation; and in any case that a star is removed
from a location, that star is nulled and removed from the scene even if it is being redrawn at another location. 
And then a new star is created and assigned to the proper location. A smarter and faster system could
have been implemented had there been more time. </p>

<p>Most of the Block functions are simple accessor or mutator functions. The only functions needing 
a more detailed explanation are foundMatch and gatherBlocks, and they will be explained in Game Play.
markedBool and coloredBool are used in many of these algorithms and will be detailed there as well.
</p>

<h3>Game Play</h3>
<b>Primary Author: Daniel Keasler</b>

<p>Game play is started through either selecting a game mode, restarting your current game mode in
the pause menu, or playing another game after your current game has ended. Selecting a game mode
will set one of the three game mode flags to 1. Each potential new game started calls the startGame
function, and some pieces are not started or shown depending on the game mode flags. Endless mode 
does not show the time bar nor start the time bar. Survival mode displays and starts a slightly 
modified time bar, a progress bar. More information on these is written in the Timers section. Each new game deletes and nulls the previous board, and then
dynamically allocates and randomly generates a new board. </p>

<p>The application now waits for a mousePressEvent. The game board itself needs 1 mouse event to
properly register graphics scene mouse events. This also officially starts the game timer and enables
interaction with Blocks. </p>

<p>Every mouse event after the first has the same process. The game 
board mouse events are temporarily frozen to process 1 match at a time. The x and y of the event 
are obtained, which is then used to obtain a Block in the two dimensional array of objects. The code to then check for an initial match was placed in the Block class because the 
Block Class contained the appropriate references and it was another process we could move out of our
long MainWindow class. FoundMatch checks that Block objects neighboring Blocks for an equal color 
value and returns true if it finds one. If it returns true, then processMatch is called and the obtained block is sent as a parameter. 
The next mouse event still cannot start until after the mouse press event function returns to its caller, so if processMatch is called, 
mouse press events in the graphics scene will be disabled while processMatch is being executed.</p>

<p>The first thing that happens in processMatch is all of the adjacent and matching blocks are gathered. 
gatherBlocks takes in a vector<Block*> and continuously expands through recursion as long as the pointer
reference exists and the color integer value matches. This is a recursive function in the Block Class because the array 
index access function would have been messier and it allows for more code to be placed outside the 
applications long main window. markedBool is necessary to avoid endless recursion amongst different directional
accesses of the same Block object. </p>

<p>Each of the current matching and adjacent blocks are now checked for a star in the checkSpecial function.
Using the gathered blocks from the previous step, if any Block objects graph image is not 0, a number of
bookkeeping statements are executed in addition to calling bombCollector to gather blocks from a bomb
explosion. Because the explosion (collection) is a 3x3 subset of the two dimensional array of blocks centered at the 
star block, array accesses were the cleanest choice. </p>

<p>Now the blocks are sorted relatively in each column. Assuming similar x values, no 
Block further down the vector will have a lower y value. Sorting was not optimal
and very likely not necessary, but the implementation of sorting worked properly with
the rest of the algorithms. With more time, a better implementation between what sorting was intended to do
(assure proper re-coloring order) and how determing new colors was implemented (assuming the blocks were sorted).</p>

<p>The conclusion of sorting leaves every single collected block as 
Black. A timer is placed here to force the game to show the blacking transition. This is discussed more
in the Timers section.</p>

<p>The score and bomb bar are updated. Scoring is described in the Score Class and the ScoreFrame Class, 
and the bomb bar (which is similar to the time bar) is described in the Timers section. The progress bar
is updated if you are playing in survival mode. </p>

<p>Finally the new colors are determined. The algorithm will search upwards in a column for 
a color that a particular Block can steal. Stars also have to properly be stolen as well. coloredBool is used to determine if a Block needs a 
color change. We could have also used the black color to check for necessary color changes, but while
we didn't know how to force transitions a more intelligent method could not be implemented. This is 
done using array accessing because the code is slightly cleaner to decrement the y index value as 
searching upwards in a column. </p>

<p>The game now waits for another mouse event. The game ends when the user exits the game or when the time runs out.</p>

<h3>User Interface</h3>
<b>Primary author: Devin Rusnak</b>


<h3>Timers</h3>
<b>Primary author: Mikael Son</b>


<div>
<h3>Shuffling</h3>
<b>Primary author: Shannon Harwick</b>

<br>
<i>Shuffle Design</i>

<p>
A key fault with the original Plock game is that its only shuffling mechanism (Random Shuffle)
did not provide much reward for those players who attempted to eliminate blockS strategically
rather than by spam-clicking.

The penalty to shuffling is the time it requires to analyze a new board.  This penalty is not 
felt by spam clickers but can be a major obstacle for strategists.  

The rewards are also unbalanced. 
The Random Shuffle rewards the spam-clicker by easily opening up new clickable paths.
The strategists's board, on the other hand, may be destroyed because a major block group
could be split into smaller pieces that cannot be easily connected.  Again, the spammer 
does not suffer this consequence.  

We incorporated this feature in our own game because it makes the game more exciting by 
allowing the user to recover from a board with few options.  However, we added two more
shuffling mechanism that offer better rewards to players who think.
</p>

<p>
The first new shuffle method we implement is the Flip.  This simply flips the board
along the central horizontal axis.  The top row and the bottom row swap places, 
as do the 2nd and the 2nd-to-last rows, etc.  Note that this method is reversible
by simply calling it twice.

This method won't give any benefit to the
spammer, but it allows the strategist to maintain a large group of blocks but change
the side on which new blocks will fall.  The cost is minimal since the structure of the
board is simply a reflection of the board the user was just looking at.  At one point,
we implemented a similar flip around the vertical axis.  However, this opens up no new options
to the player, so we removed it.
</p>
The second new shuffle method is the Rotate, which rotates the board 180 degrees around 
the board's center.  Thus the top left corner of the board rotates to become the bottom 
right corner.  This method, like Flip, is easily reversible and provides benefits only
to a strategist.
</p>


<i>Shuffle Implementation</i>
<p>
Each shuffling strategy is performed via its own method: shufflePressed(), rotate(), and horizontalFlip().
In each case, the colors and bombs are traded pairwise for a number of pairs of blocks.
After swapping, the blocks are repainted.  
The swaps are as follows:
<ul>
<li>For Random Shuffle, 5,184 (= the square of the area of the game board) random trades occur.</li>
<li>For Rotate, all the blocks on the left side of the board are traded with their appropriate 
match on the right side of the board (e.g., top left corner and bottom right corner).</li>
<li>For Flip, all the blocks on the top half of the board are traded with their appropriate 
match on the bottom half of the board (e.g., top left corner and bottom left corner).</li>
</ul>
</p>
</div>



<h3>Scoring</h3>
<b>Primary author: Shannon Harwick</b>

<br><i>Score Design</i>
<p>
The score is designed to reward a player for thinking rather than random clicking.  A
thoughtful player must manipulate the board to create opportunities to eliminate 
very large groups of blocks.  In Plock, scoring is quadratic based on the number of
blocks eliminated in one click.  This does make larger groups worth more points per
block than smaller groups, but our user testing indicates that
the gain does not compensate for the loss in quantity due to spam-clicking.  

We considered various mechanisms to push the player away from spam-clicking:
<ul>
<li>Subtract points for clicking single blocks</li>
<li>Decrease the bomb bar for clicking single blocks</li>
<li>Decrease the time bar for clicking single blocks</li>
<li>Increase the degree of the polynomial in the scoring equation</li>
</ul>

We ultimately chose the last because it offers the player a reward for good behavior 
rather than punishment for bad.  The final score equation is: 
<br><br>
Score = (n-1)^4
<br>where n = # of eliminated blocks
<br><br>
</p>

<i>Score Implementation</i>
<p>
[[TO BE COMPLETED]]
</p>

<h3>Color Schemes</h3>
<b>Primary author: Shannon Harwick</b>
[[TO BE COMPLETED]]


<h3>Game Modes</h3>
<b>Primary author: Daniel/Mike/Devin</b>
[[TO BE COMPLETED]]

<h3>User Feedback</h3>
<b>Primary author: Daniel Keasler</b>
<p>In the last month of the project we had a playable game that we showed to family and friends and they gave us excellent feedback.
We were first asked to show your score after the game ended, which resulted in displaying a game over menu that showed your score.
We had multiple complaints about colors. So we implemented color schemes the user could choose through the settings menu. This is
discussed more in the color schemes section. Another observation from others playing the game was that spam clicking was more 
successful. Since our application is intended for a phone and we never tested it on a phone, we can't assume anything for 
finger presses but we did incentivize scoring to make it worth more for thinking about what blocks you were clearing. This 
is discussed in the Scoring section. </p>

<h3>Unresolved Issues</h3>
<b>Primary author: All</b>



</body>
</html>