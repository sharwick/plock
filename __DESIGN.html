<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BOMBSTAR: Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BOMBSTAR
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">

</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
    
        <li><a href="__Readme.html"><span>Readme</span></a></li> <!- SH Added -->
      	<li><a href="__Instructions.html"><span>Instructions</span></a></li> <!- SH Added -->
      	<li><a href="__Design.html"><span>Design</span></a></li> <!- SH Added -->
		<li><a href="index.html"><span>Doxygen Output</span></a></li> <!- SH Added -->
   
    </ul>
  </div>
</div><!-- top -->



<div class="header">
  <div class="headertitle">
<div class="title">BOMBSTAR Documentation</div>  </div>
</div><!--header-->
<div class="contents">
</div><!-- contents -->

<br><br>
<img src="./Images/DesignA.png" alt="Design A">
<img src="./Images/DesignB.png" alt="Design B">

<h3>Introduction</h3>
<p>Below we have included all of the important components as listed above. Each
section has at least one author describing the relavant components. </p>





<h3>Game Play</h3>
<b>Primary Author: Daniel Keasler</b>

<p>Game play is started through either selecting a game mode, restarting your current game mode in
the pause menu, or playing another game after your current game has ended. Selecting a game mode
will set one of the three game mode flags to 1. Each potential new game started calls the startGame
function, and some pieces are not started or shown depending on the game mode flags. Endless mode 
does not show the time bar nor start the time bar. Survival mode displays and starts a slightly 
modified time bar, a progress bar. More information on these is written in the Timers section. Each new game deletes and nulls the previous board, and then
dynamically allocates and randomly generates a new board. </p>

<p>The application now waits for a mousePressEvent. The game board itself needs 1 mouse event to
properly register graphics scene mouse events. This also officially starts the game timer and enables
interaction with Blocks. All game play events are executed from MainWindow_UI.cpp unless stated otherwise. </p>

<p>Every mouse event after the first has the same process. The game 
board mouse events are temporarily frozen to process 1 match at a time. The x and y of the event 
are obtained, which is then used to obtain a Block in the two dimensional array of objects. The code to then check for an initial match was placed in the Block class because the 
Block Class contained the appropriate references and it was another process we could move out of our
long MainWindow class. FoundMatch checks that Block objects neighboring Blocks for an equal color 
value and returns true if it finds one. If it returns true, then processMatch is called and the obtained block is sent as a parameter. 
The next mouse event still cannot start until after the mouse press event function returns to its caller, so if processMatch is called, 
mouse press events in the graphics scene will be disabled while processMatch is being executed.</p>

<p>The first thing that happens in processMatch is all of the adjacent and matching blocks are gathered. 
gatherBlocks takes in a vector<Block*> and continuously expands through recursion as long as the pointer
reference exists and the color integer value matches. This is a recursive function in the Block Class because the array 
index access function would have been messier and it allows for more code to be placed outside the 
applications long main window. markedBool is necessary to avoid endless recursion amongst different directional
accesses of the same Block object. </p>

<p>Each of the current matching and adjacent blocks are now checked for a star in the checkSpecial function.
Using the gathered blocks from the previous step, if any Block objects graph image is not 0, a number of
bookkeeping statements are executed in addition to calling bombCollector to gather blocks from a bomb
explosion. Because the explosion (collection) is a 3x3 subset of the two dimensional array of blocks centered at the 
star block, array accesses were the cleanest choice. </p>

<p>Now the blocks are sorted relatively in each column. Assuming similar x values, no 
Block further down the vector will have a lower y value. Sorting was not optimal
and very likely not necessary, but the implementation of sorting worked properly with
the rest of the algorithms. With more time, a better implementation between what sorting was intended to do
(assure proper re-coloring order) and how determing new colors was implemented (assuming the blocks were sorted).</p>

<p>The conclusion of sorting leaves every single collected block as 
Black. A timer is placed here to force the game to show the blacking transition. This is discussed more
in the Timers section.</p>

<p>The score and bomb bar are updated. Scoring is described in the Score Class and the ScoreFrame Class, 
and the bomb bar (which is similar to the time bar) is described in the Timers section. The progress bar
is updated if you are playing in survival mode. </p>

<p>Finally the new colors are determined. The algorithm will search upwards in a column for 
a color that a particular Block can steal. Stars also have to properly be stolen as well. coloredBool is used to determine if a Block needs a 
color change. We could have also used the black color to check for necessary color changes, but while
we didn't know how to force transitions a more intelligent method could not be implemented. This is 
done using array accessing because the code is slightly cleaner to decrement the y index value as 
searching upwards in a column. </p>

<p>The game now waits for another mouse event. The game ends when the user exits the game or when the time runs out.</p>

<h3>Block Class</h3>
<b>Primary Author: Daniel Keasler</b>

<br><br>
<img src="./UML Diagrams/Block.jpg" alt="Block Object">
<br>

<p>The block class is the game play data structure of our BOMBSTAR game. 
Our application's MainWindow would have a two dimensional array of Block objects, corresponding 
to the game board with the same number of elements in each. Each individual Block object would
contain pointer references to four adjacent Blocks. For example, if a Block could be accessed in
the main window with indexes x and y, the Block would contain the pointer references of the Blocks 
at indexes (x+1,y) (x-1,y) (x, y+1) (x, y-1). This allows some of our functions to be recursive 
functions at the Block level instead of adding more to our main window through accessing arrays. 
The Block also contained a CoordX and CoordY value. These were the same accessing indexes at the
Block level. In many cases, many Blocks will be contained in a vector<Block*>, and to have constant
time access to that Block's neighbors in MainWindow, the coordinates of the Block needed to be 
easily obtained. </p>

<p>The block class later was changed to inherit from QGraphicsRectItem. By doing this, we could reimplement
the mouse press event for game play interaction and the blocks could be displayed on a QGraphicsScene. </p>

<p>Along with inheriting from QGraphicsRectItem, we devised a system 
that mapped an integer value to a QColor. More on this is written in the Colors Schemes, but the 
Block Class only contains an integer value for easy color comparisons. The same integer value between
Blocks means those Blocks have the same color. This was also applied to representing stars on the 
Blocks as well. A graphImage of 0 meant that no star was being graphically represented on that particular
Block, a graphImage of 2 meant that a star was represented on that Block. This numbering was originally intended for 
bombs (now stars) as well as arrows but there wasn't enough time to properly implement arrows. 
The extra arrows would have had graphImage values of 3 and 4 for vertical and horizontal, and potentially
5 for all four directions. </p>

<p>The stars are made from QGraphicsSimpleTextItems with unicode character 0x2605 and are members of the Block class. 
To properly register stars in the Block class, the star was created in the block when the block was created and
the pointer reference is assigned later with another randomly created star. 
Each star is created when the bomb bar fills up, and then that pointer is assigned to that Block's star pointer.
The function that generates coordinates for the new star can also take in known coordinates for relocation, and in any case that a star is removed
from a location, that star is nulled removed from the scene even if it is being redrawn at another location. 
And then a new star is created and assigned to the proper location. It is only deleted when the game is over. A smarter and faster system could
have been implemented had there been more time. </p>

<p>Most of the Block functions are simple accessor or mutator functions. The only functions needing 
a more detailed explanation are foundMatch and gatherBlocks, and they will be explained in Game Play.
markedBool and coloredBool are used in many of these algorithms and will be detailed there as well.
</p>

<h3>User Interface</h3>
<b>Primary author: Devin Rusnak</b>

<p>The user interface is all custom written, we made no use of the aweful mainwindow.ui form. Aside from letting it create the centralWidget which we use as the base layer widget.
</p>

<i>Scalability</i>
<p>First and foremost this game is ment to be played on a phone, which come in endless varieties these days. So scalability of the 
user interface was paramount when it was designed. The idea for the implementation came from focusing on the game board. Since it is the main
piece of the interface it's crucial that it gets displayed correctly. One of the first things done when the user interface is being setup, is that the phone screen size is examined. Besides being used to make sure all the widgets take up the entire screen, the size is used to determine the best square size to make the game blocks so that the game board doesn't extend beyond the phone screen. This determined size is stored as 
the blockSize, and each piece of the interface is sized based on it. There are no fixed sizes for any of the interface items, they all are 
sized based on some arithmetic based on the blockSize. Most of the menus though are just based on the screensize as it is an easier operation
if the menu had to be, say 80% of the horizontal and 60% of the vertical.
</p>

<i>The Game Board</i>
<ul> <i><a href="../code/mainwindow_UI.cpp">Click here for code.</a></i>
<br>Search for the following terms to find relevant section of code:
<li>"MainWindow::setupWindows"</li>
<li>"MainWindow::mousePressEvent"</li>
</ul>
<p>The game board is the main feature of the user interface. It is essentially the entire game, everything else just allows the user to get the game board setup or has some other axillary function. The game board itself is a QGraphicsView with a QGraphicsScene, which allows the blocks (QGrapicsRectItem) to be displayed. The original idea was to have the blocks "fall" down as the ones below are cleared and this implementation would support that. We also wanted to have the ability to rotate the phone and have the blocks dropping down from the new "top" of the board. These two features didn't end up getting implemented due to time constraints, but the structure is there to support them. Another reason for using QGraphicsItems was so that we could display our different bombs on them. This proved to be much more difficult than orginally thought and used up a fair amount of time. Thus we only have one bomb that is a unicode star. The score frame is a custom object that both updates and displays the score nicely. The bomb and time bars are stacked colored QLabels that are updated to reflect the time remaining or bomb amount gained. Both of these items will be discussed later by their authors. The buttons at the bottom of the screen rotates, flips, or shuffles the board, or brings up the pause menu. Due to issues with the QGridLayout it was difficult to get the game board in the layout and have the buttons positioned nicely below it. Thus they are not placed in the layout but are placed based on the know sizes of the items above them and the screen size.
<br></br>
When the user clicks on a block the mousePressEvent is triggered and propagated. When the first click occurs they block that is clicked calls grabMouse() which allows the event to be propagated to its parent, which is the centralWidget. The centralWidget's parent is the mainwindow class and the event gets past to it. After the first click each new click causes the new block to be the mouse grabber and the last one automatically calls ungrabMouse(). In mainwindow_UI the mousePressEvent(event) is overwritten. It recieves the (x,y) coordinates of the last widget to recieve the event, which is the centralWidget. Then to find the X coordinate for the blockArray, all that needs to be done is to divide the xPos from the event by the blockSize. For the Y coordinate it takes a little more calculation. First a QPoint is created and set to the position of the QGraphicsView. By calling point.y(), the origin Y coordinate is obtained. Then this value is subtracted from the yPos obtained from the mouse event. This gives the Y coordinate relative to the QGraphicsView, once divided by the blockSize, the Y coordinate for the block array is known. Then the obtained coordinates get a block from the array and it's function to check for matches is called. If it finds one processMatch is called with the block clicked as a parameter.
</p>

<i>Game Modes</i> 
<ul> <i><a href="../code/mainwindow_UI.cpp">Click here for code.</a></i>
<br>Search for the following slots to find relevant section of code:
<li>"MainWindow::standardMode"</li>
<li>"MainWindow::survivalMode"</li>
<li>"MainWindow::endlessMode"</li>
</ul>
<p>For the different game modes certain interface features need to be changed. Standard Mode is the base mode and has all the items visible. When in Survival Mode the timer bar becomes the progress bar and its label is changed accordingly. It starts with it displaying the bar half full and the user loses once it gets to zero. When the user fills the progress bar completely the level complete menu is displayed which informs the user which level they have completed. For Endless Mode the progress bar and label are simply hidden and the user gets to play forever, which is not possible so we capped the score at one hundred million points. A kill screen was thought of to go here in true arcade fashion, but as it is <i>Endless Mode</i> the user can still play past this point, the score is just no longer updated. This score cap also applies to Survival Mode but would be very difficult to achieve, and is simply impossible to achieve in sixty seconds for Standard Mode.
</p>

<i>The Menus</i>
<ul> <i><a href="../code/mainwindow_UI.cpp">Click here for code.</a></i>
<br>Search for the following terms to find relevant section of code:
<li>"MainWindow::setupGameScreen"</li>
</ul>
<p>The menus act as the main state control mechanism when the user is not currently playing a game. The menus can be thought of as existing on 
two different layers. The bottom layer is the defualt centralWidget which the game board is placed. The rest of the menus can be thought to exist on a top layer over the game board. The menus are QGroupBoxes which fill the screen and are displayed over the base layer. The menus are:
<ul> 
<li><b>Main</b> - Inital menu from which rest of game is accessed.</li>
<li><b>Game Mode Selection</b> - Allows user to select a game mode.</li>
<li><b>High Scores</b> - Displays the top 5 scores for each game mode.</li>
<li><b>Settings</b> - Allows user to select from preset color palletes.</li>
<li><b>About</b> - Authors info and how-to play the game.</li>
</ul>
Once the user has selected a game mode and starts playing the game there are three menus that the user can interact with. They are:
<ul>
<li><b>Pause</b> - Stops timers and allows user to access the high score & settings menus or quit the game.</li>
<li><b>Level Complete</b> - Displays on Survival Mode when the user fills the progress bar.</li>
<li><b>Game Over</b> - Displays the final score and allows user to restart game, access high scores, or quit the game.</li>
<li><b>Confirm Quit</b> - When the user wants to quit the game this menu confirms that choice.</li>
</ul>
</p>

<i>Performance</i>
<p>The menus have several items each and the transitions between the menus needs to be quick and easy. They are also the main thing the 
user interacts with, so they need to look nice. Both of these objectives are achived by the use of QGroupBoxes and QLayouts. By giving each QGroupBox a QLayout the items for each menu can be simply added to the layout. The layouts keep the items organized and lined up nicely, plus they are then associated with the QGroupBox the layout is added to. This means that only the box needs to be shown or hidden for all the items associated with the menu to be shown or hidden as well. This feature allows the code needed for transitions between menus to be minimal.The buttons in the menus are the means through which the game transitions from state to state. The transitions are handled by custom slots created in mainwindow_UI. By connecting the buttons to these slots it helps to keep the code for the transitions organized. Since the items are created with some scale of the blockSize, all the items have similar scales, and thus look aesthetically pleasing.
</p>

<h3>Timers</h3>
<b>Primary author: Mikael Son</b>
<p>Timers are built using 'QTimer' to update, and 'QLabel' show the actual figure of the timer. 
Since timebar and bombbar need to be decreasing over time, timer is used for both and in every mode of 
the game. In the beginning, we tried to create the timebar using a 'QProgressbar', but it hardly was functional. 
so I came up with just simply using two QLabels, one for the layer and another for filling the timer. <p/>

<p><i>TimeBar</i></p>
<p>Using the time slots, timebar created with QLabels will be updated depending on the frequency of calling the time slot 
, filling the bar or decreasing the bar. Frequency of calling time slot can be controlled using nanosecond unit, 
and this frequency have effects on how smoothly the timebar works in terms of decrements. So if I was to have 
60 seconds of the game time and I were to call the time slot once every second, I will call the time slot 60 times 
until the game ends. But the decrement of the time bar would not look pretty since it is just chunk amount of time 
bar just disappearing every second. So rather, I would set it to call the time slot four times every second, 
I would decrease the time bar every 250 nano second which will have the time bar working more smoothly. int variable 'currentTime' 
was used to keep track of the timebar more accurately. More specification provided below in BombBar.</p>
<p><i>BombBar</i></p>
<p>Functioning mostly the same as TimeBar. Using the bomb time slot, Bombbar will be updated to decrease every second, 
also getting filled up whenever the blocks are eliminated. Bombbar will be activated as soon as the game starts. 
Whenever there is a mouse click event, the method 'updateBomb' with the parameter of 'nBlocks' will be used 
to update the Bombbar. Depending on how many blocks are removed at once, amount of the fill to the Bombbar will 
be calculated using the parameter 'nBlocks', and will update the Bombbar. Whenever 'updateBomb' is called, it 
will check the Bombbar's status: if Bombbar is empty or not, or if Bombbar is filled all the way up. If the 
Bombbar is filled again out of emptiness, then it needs to be reactivated, and when the Bombbar is filled all the 
way up, then a bomb is to be generated. Bombbar also uses an int variable called 'bcurrentTime' to check the current 
state of the Bombbar more accurately. 'bcurrentTime' is basically a time counter for the Bombbar, keeping track of 
how many seconds are left for the bar to be empty. This int variable will be decreased in terms of seconds when 
the Bombbar itself is updated to decrease, and vice versa. This making changes to int variable required quite a precise calculation, 
trying to make Bombbar work more smoothly, at the same time, we needed this so that the function does not call 
the method to decrease the Bombbar and cause the error message of 'cannot go negative' when it is empty.</p>
<p><i>ProgressBar</i></p>
<p>Progressbar is just a different label for Timebar used in Survival Mode, with slightly added functionality. Progressbar uses same 
technique as Bombbar to check if the bar is empty or filled up all the way. If the bar is filled up all the way, then 
the game will proceed to next level; if the bar is empty, it will end the game.</p>

<p><i>Issues</i></p>
<p>There were some issues concerning 'QTimer' and 'QLabel'. </p>
<p>For leveling feature for the Survival Mode, I needed 
to implement the Progressbar to work faster as the player surpass each level. Problem came from this. Our goal was 
to have the Progressbar working properly in high level with appropriate difficulty, at the same time, smoothly. This 
was a little hard to manage in the beginning because I got into problem with QLabel at first. How QLabels are used 
to work as a Timebar was that each QLabels were given initially the width and its maximum width. To fit the Timebar 
inside the smartphone screen, there first came the limit of how big of a width the QLabel could have. I am decreasing 
the maximum width of the QLabel used for filling of the Timebar to show the timer progress. First of all, I can only 
decrease the width only by whole number, which means that the smallest value of decrement of width is 1. This became an 
issue when it came to implementing a Progressbar for higher level in Survival Mode. The Progress Bar needs to be 
decreasing faster with smoothness in higher level. If I only tried to increase the decrement of the width to make it decrease 
faster, it does not look as smooth as it used to be, and this is where the QTimer implementation comes in.</p>
<p>I started implementing QTimer to help QLabel issue, and my solution was to call the time slot more frequently rather 
than increasing the amount of decrement of the width. This solved the problem until when the player reaches the level higher 
than 8 in the Survival Mode. I was to use nanosecond unit to set the frequency of calling the time slot, and this also had 
a limit of not being able to use integers but whole numbers. When the player reaches high level and the int variable used for 
applying nanoseconds to the timer reaches 1, there was no progress in terms of the Progressbar decreasing faster. So I had no 
choice but to increase the decrement of the width, even if the smoothness could not be perfect. But to take care of this, I 
just increase the level of the Survival Mode, and so far it is pretty hard to beat level 10 of the Survival Mode, so it is 
working pretty fine for now. </p>



<div>
<h3>Shuffling</h3>
<b>Primary author: Shannon Harwick</b><br>

<br>
<i>Shuffle Design</i>

<p>
A key fault with the original Plock game is that its only shuffling mechanism (Random Shuffle)
did not provide much reward for those players who attempted to eliminate blockS strategically
rather than by spam-clicking.

The penalty to shuffling is the time it requires to analyze a new board.  This penalty is not 
felt by spam clickers but can be a major obstacle for strategists.  

The rewards are also unbalanced. 
The Random Shuffle rewards the spam-clicker by easily opening up new clickable paths.
The strategists's board, on the other hand, may be destroyed because a major block group
could be split into smaller pieces that cannot be easily connected.  Again, the spammer 
does not suffer this consequence.  

We incorporated this feature in our own game because it makes the game more exciting by 
allowing the user to recover from a board with few options.  However, we added two more
shuffling mechanism that offer better rewards to players who think.
</p>

<p>
The first new shuffle method we implement is the Flip.  This simply flips the board
along the central horizontal axis.  The top row and the bottom row swap places, 
as do the 2nd and the 2nd-to-last rows, etc.  Note that this method is reversible
by simply calling it twice.

This method won't give any benefit to the
spammer, but it allows the strategist to maintain a large group of blocks but change
the side on which new blocks will fall.  The cost is minimal since the structure of the
board is simply a reflection of the board the user was just looking at.  At one point,
we implemented a similar flip around the vertical axis.  However, this opens up no new options
to the player, so we removed it.
</p>
<p>
The second new shuffle method is the Rotate, which rotates the board 180 degrees around 
the board's center.  Thus the top left corner of the board rotates to become the bottom 
right corner.  This method, like Flip, is easily reversible and provides benefits only
to a strategist.
</p>


<br>
<i>Shuffle Implementation</i>
<p>
Each shuffling strategy is performed via its own method: shufflePressed(), rotate(), and horizontalFlip().
In each case, the colors and bombs are traded pairwise for a number of pairs of blocks.
After swapping, the blocks are repainted.  
The swaps are as follows:
<ul>
<li>For Random Shuffle, 5,184 (= the square of the area of the game board) random trades occur.</li>
<li>For Rotate, all the blocks on the left side of the board are traded with their appropriate 
match on the right side of the board (e.g., top left corner and bottom right corner).</li>
<li>For Flip, all the blocks on the top half of the board are traded with their appropriate 
match on the bottom half of the board (e.g., top left corner and bottom left corner).</li>
</ul>
</p>


<ul> 
<i><a href="../code/mainwindow_ui.cpp">Click here for code.</a></i>
<br>Search for the following terms to find relevant section of code.
<li>void MainWindow::horizontalFlip()</li>
<li>void MainWindow::rotate()</li>
<li>void MainWindow::shufflePressed()</li>
</ul>


</div>



<h3>Scoring</h3>
<b>Primary author: Shannon Harwick</b>

<br><i>Score Design</i>
<p>
The score is designed to reward a player for thinking rather than random clicking.  A
thoughtful player must manipulate the board to create opportunities to eliminate 
very large groups of blocks.  In Plock, scoring is quadratic based on the number of
blocks eliminated in one click.  This does make larger groups worth more points per
block than smaller groups, but our user testing revealed that
the gain does not compensate for the loss in quantity due to spam-clicking.  

We considered various mechanisms to push the player away from spam-clicking:
<ul>
<li>Subtract points for clicking single blocks</li>
<li>Decrease the bomb bar for clicking single blocks</li>
<li>Decrease the time bar for clicking single blocks</li>
<li>Increase the degree of the polynomial in the scoring equation</li>
</ul>

We ultimately chose the last because it offers the player a reward for good behavior 
rather than punishment for bad.  The final score equation is: 
<br><br>
<ul>Score = Multiplier * (n-1)^4
<br>where n = # of eliminated blocks
</ul><br>
</p>

<p>
We have implemented an endless mode, but sadly, we can't give an infinite number of points.
In order to handle very large scores and multipliers, we implemented a score cap of 
100,000,000 and a multiplier cap of 50.  Once a player reaches these scores, he or she 
may continue to play, but no further points or multiplier levels may be attained.  We
considered changing the score variable to a long long type in order to allow even 
higher scores, but we decided this would require changes to the user interface that would
not be visually appealing.  
</p>

<i>Score Implementation</i>


<br><br>
<img src="./UML Diagrams/Score.jpg" alt="Score Object">
<br>


<br><br>
<img src="./UML Diagrams/ScoreFrame.jpg" alt="Score Frame Object">
<br>

<br><i><a href="../code/Score.cpp">Click here for Score code.</a></i><br>
<br><i><a href="../code/ScoreFrame.cpp">Click here for ScoreFrame code.</a></i><br>

<p>
The score is stored in a Score object as an integer.  Every time blocks are eliminated, 
updateScore() is called to increment the current score value with the value of the 
new blocks eliminated.  Originally the plan was to incorporate a speed bonus (i.e., 
the player would get extra points for multiple successful moves in a short time period).  
We ultimately chose not to implement this, as it offers a benefit to spam-clickers.  
Thus, in our current implementation, the speedBonus input is always set to false.  
</p>

<p>
The Score object also contains the current multiplier.  The multiplier reflects the 
number of bombs that have been eliminated.  Eliminate more bombs to get a higher multiplier.
Once a certain multiplier has been reached, all subsequent points earned are multiplied
by that value before adding to the score.  The multiplier begins the game at 1 and is 
incremented every time a bomb is eliminated.  
</p>

<p>
When a new game is started, resetScore() is called to reset the multiplier to 1 and 
the current score to 0.  
</p>

<p>
A separate item, ScoreFrame, is created for the score board.  After the score has been
updated, this change must be reflected on the score board viewed by the player.  The 
update() method makes this update.  When the game is reset, resetScoreBoard() sets the 
score board back to 0.  
</p>

<h3>High Scores</h3>
<b>Primary author: Devin Rusnak</b>
<br></br>
<img src="./UML Diagrams/highScores.jpg" alt="High Score Object">
<br></br>
<i><a href="../code/highScores.cpp">Click here for code.</a></i>
<br></br>
<i>Implementation</i>
<p>As this is an arcade game a high score list is a must have feature. The HighScores object does four things:
<ul>
<li>Stores the top five high scores for each game mode in integer arrays.</li>
<li>Sorts new high scores into said arrays when they are achieved.</li>
<li>Reads/Writes high scores to a text file to be saved and used.</li>
<li>Maintains the QLabels that display the scores in the high scores menu.</li>
</ul>
When the game starts the file is opened and the scores are read in and stored into the integer arrays. The file is formated so that each line contains one score and the scores are in order starting with the top five standard mode scores, then the top five survival mode scores with the level obtained, and then the top five endless mode scores. In standard and survival modes when the game ends the score is sent to the addScore function which sorts the score into the proper array based on the game mode. If the score is in the top five the function returns one which in mainwindow_UI shows a label saying the user got a high score. It also then writes the new list of high scores to the same text file. The QLabels that are used to display the scores in mainwindow_UI are part of this object class so that they can be updated easily. When a new high score is added the score can be converted to a nicely formatted QString and the corresponding QLabel's text can be set to it. Originally more than just the top five scores were going to be saved but there were two issues. First since the score was capped at one hundred million only one score could fit on a line. Second having more than five scores would cause the list to go off of the screen and create a scroll screen situation. Having just the five scores for each mode fits quite nicely on the screen so it was left at that.
</p>
<i>Issue</i>
<p>The text file is not opened correctly. Several different methods were tried, QFile, QFile and QDataStream, C++ STL streams, but none of them worked. Since this was one of the last things implemented there was not enough time to get it fully functional. The top scores from the current session are stored, sorted, and displayed correctly in the high score menu. They are just not saved between game launches.
</p>

<h3>Color Schemes</h3>
<b>Primary author: Shannon Harwick</b>

<br><br><i>Color Scheme Design</i>
<p>
In response to feedback from our presentations and from our test users, we 
decided to implement multiple color schemes and to include a Setting menu where a user
can choose the color scheme that most appeals to him or her.  Of the 5 color schemes,
four are colorblindness-safe.  We included one scheme that is not color-blind safe because 
some of the users who do <i>not</i> suffer from colorblindness found some of the colors 
too similar in the safe schemes.  The source for the color schemes is: 
<a href="http://colorbrewer2.org">Colorbrewer</a>.  Note that the background for all 
color schemes was chosen to be the most extreme shade of black.  
This is necessary since our game is quite color-intensive and thus requires a strong 
contrast.  
</p>



<i>Color Scheme Implementation</i>

<br><br>
<img src="./UML Diagrams/Colors.jpg" alt="Color Object">
<br>

<br><i><a href="../code/Colors.cpp">Click here for Color code.</a></i><br>

<p>
All 5 color schemes were placed into a single Color object.  Each color scheme is 
represented by an integer value from 0 to 4 (int colorScheme).  The active color scheme 
is contained in an array (QColor colorArray[7]) and is used to create 
a QPalette that is used to paint all objects.  
</p>
<p>
When the user changes the Color Scheme 
setting, this is implemented by changing the integer in the Color object, updating the colorArray, updating the 
QPalette, and repainting all existing objects.  This is completed by attaching a slot 
(changeColorScheme) to the QSlider used by the player to adjust the setting.  
The QPalette is updated in MainWindow::changeColorScheme().  After the palette is created,
the gameboard, all QPushButtons, and all QLabels are repainted.  The QPushButtons and 
QLabels are stored in their own vectors (labelVector and buttonVector) to facilitate this
process.  
</p>


<i>Bug</i><br><br>
One bug remains outstanding here.  QPushButtons do not respond to color changes 
on all machines/AVDs (Only 1 of our 4 computers shows the changes in the QPushButtons).  
This is true regardless of whether color changes are implemented 
using style sheets or QPalette (both techniques work correctly on the 1 computer).  
The other objects change color as expected.  

<h3>Game Modes</h3>
<b>Primary author: Daniel/Mike/Devin</b>
[[TO BE COMPLETED]]

<h3>User Feedback</h3>
<b>Primary author: Daniel Keasler</b>
<p>In the last month of the project we had a playable game that we showed to family and friends and they gave us excellent feedback.
We were first asked to show your score after the game ended, which resulted in displaying a game over menu that showed your score.
We had multiple complaints about colors. So we implemented color schemes the user could choose through the settings menu. This is
discussed more in the color schemes section. Another observation from others playing the game was that spam clicking was more 
successful. Since our application is intended for a phone and we never tested it on a phone, we can't assume anything for 
finger presses but we did incentivize scoring to make it worth more for thinking about what blocks you were clearing. This 
is discussed in the Scoring section. </p>

<h3>Unresolved Issues</h3>
<b>Primary author: All</b>



</body>
</html>
